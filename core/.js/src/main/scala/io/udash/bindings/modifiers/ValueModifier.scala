package io.udash.bindings.modifiers

import com.avsystem.commons._
import io.udash.bindings._
import io.udash.properties.single.ReadableProperty
import io.udash.utils.Registration
import org.scalajs.dom._

import scala.scalajs.js

private[bindings]
trait ValueModifier[T] extends Binding with DOMManipulator {
  import Bindings._

  protected def property: ReadableProperty[T]
  protected def builder: (T, Binding.NestedInterceptor) => Seq[Node]
  protected def checkNull: Boolean
  protected def listen(callback: T => Unit): Registration

  override def applyTo(t: Element): Unit = {
    var elements: Seq[Node] = Seq.empty

    def rebuild(propertyValue: T): Unit = {
      killNestedBindings()

      val oldEls = elements
      val newEls: Seq[Node] =
        builder(propertyValue, nestedInterceptor)
          .optIf(!checkNull || propertyValue != null)
          .filter(_.nonEmpty)
          .getOrElse(emptyStringNode())

      elements = if (newEls.size == 1 && newEls.head.isInstanceOf[DocumentFragment]) {
        //DocumentFragments nodes are moved after appending, so we cannot use newEls as oldEls later on
        // (as childNodes mutate to empty). Therefore we need to use a shallow copy directly.
        //These are often generated by `scalatags.JsDom.Cap.SeqFrag`
        js.Dynamic.global.Array.prototype.slice.call(newEls.head.childNodes).asInstanceOf[js.Array[Node]]: Seq[Node]
      }
      else newEls

      replace(t)(oldEls, elements)
    }

    propertyListeners.push(listen(rebuild))
    rebuild(property.get)
  }
}














